#! /bin/sh
# chkconfig: 2345 21 20
### BEGIN INIT INFO
# Provides:         accumulo-gc
# Required-Start:   $network $local_fs 
# Required-Stop:    $network $local_fs
# Default-Start:    2 3 4 5
# Default-Stop:     0 1 6
# Short-Description: accumulo garbage collector process 
# Description:      The Accumulo garbage collector handles cleanup of old walogs and files in hdfs
### END INIT INFO

# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Do NOT "set -e"
install -d -m 0755 -o accumulo -g accumulo /var/run/accumulo

# PATH should only include /usr/* if it runs after the mountnfs.sh script
PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/lib/accumulo/bin
DESC="Accumulo Garbage Collector"
NAME=accumulo-gc
ACCUMULO_PROC=gc
DAEMON=/usr/lib/accumulo/bin/start-server.sh
IP=`ifconfig | grep inet[^6] | awk '{print $2}' | sed 's/addr://' | grep -v 0.0.0.0 | grep -v 127.0.0.1 | head -n 1`
DAEMON_ARGS="$IP gc \"garbage collector\""
PIDFILE=/var/run/accumulo/$NAME.pid
SCRIPTNAME=/etc/init.d/$NAME

STATUS_RUNNING=0
STATUS_DEAD=1
STATUS_NOT_RUNNING=3
STATUS_NOT_RUNNING_DEB=4

# Read configuration variable file if it is present
[ -r /etc/default/accumulo ] && . /etc/default/accumulo

# Load the VERBOSE setting and other rcS variables
if [ -f /lib/init/vars.sh ]; then
  . /lib/init/vars.sh
else
  log_daemon_msg() { logger "$@"; }
  log_end_msg() { [ $1 -eq 0 ] && RES=OK; logger ${RES:=FAIL}; }
fi

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.2-14) to ensure that this file is present
# and status_of_proc is working.
. /lib/lsb/init-functions

#
# Function that starts the daemon/service
#
do_start() {
    TARGET_USER_NAME="ACCUMULO_USER"
    TARGET_USER=$(eval "echo \$$TARGET_USER_NAME")

	# Return
	#  0 if daemon has been started
	#  1 if daemon was already running
	#  2 if daemon could not be started

    PID=$(check_status_of_proc)
    RETVAL=$?
    if [ "$RETVAL" -eq "0" ] ; then return 1; fi

    # Export PIDFILE so accumulo scripts will know where to write the pid to
    export PIDFILE

	su -s /bin/sh $TARGET_USER -c "$DAEMON $DAEMON_ARGS > /dev/null || return 1"

    PID=$(check_status_of_proc)
    if [ -z "$PID" ]; then
        log_warning_msg "Could not determine pid for ${DESC}"
        return 2
    fi

    return 0
	# Add code here, if necessary, that waits for the process to be ready
	# to handle requests from services started subsequently which depend
	# on this one.  As a last resort, sleep for some time.
}

#
# Function that stops the daemon/service
#
do_stop()
{
	# Return
	#  0 if daemon has been stopped
	#  1 if daemon was already stopped
	#  2 if daemon could not be stopped
	#  other if a failure occurred

    # Get the pid
    PID=$(check_status_of_proc)
    RETVAL=$?

    # If we got non-zero result, it's already dead
    if [ $RETVAL -ne '0' ] ; then return 1; fi

    # kill the process
    kill -9 $PID

    # make sure the process died but don't just blindly sleep
    for i in `seq 1 5`; do
        ps $PID > /dev/null
        RETVAL=$?
        if [ $RETVAL -ne "0" ] ; then rm $PIDFILE; return 0; fi
        sleep 1
    done

    return 2;
}

check_status_of_proc() {
    pidofproc -p $PIDFILE $PROC_NAME
}

check_status() {
    PID=$(check_status_of_proc)
    status=$?

    case "$status" in
        $STATUS_RUNNING)
            log_success_msg "${DESC} is running"
            ;;
        $STATUS_DEAD)
            log_failure_msg "${DESC} is dead and pid file exists"
            ;;
        $STATUS_NOT_RUNNING|$STATUS_NOT_RUNNING_DEB)
            log_success_msg "${DESC} is not running"
            ;;
        *)
            log_failure_msg "${DESC} status is unknown"
            ;;
    esac
    return $status
}

case "$1" in
    start)
        [ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC"
        do_start
        case "$?" in
            0) 
                [ "$VERBOSE" != no ] && log_end_msg 0 
                log_success_msg "${DESC} was started"
                ;;
            1)
                [ "$VERBOSE" != no ] && log_end_msg 0 
                log_warning_msg "${DESC} already running as $(check_status_of_proc)"
                ;;
            2)
                [ "$VERBOSE" != no ] && log_end_msg 1
                log_failure_msg "${DESC} could not be started"
                ;;
        esac
        ;;
    stop)
        [ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC"
        do_stop
        case "$?" in
            0)
                log_success_msg "${DESC} was stopped"
                ;;
            1) 
                [ "$VERBOSE" != no ] && log_end_msg 0
                log_warning_msg "${DESC} was already stopped"
                ;;
            2)
                [ "$VERBOSE" != no ] && log_end_msg 1
                log_failure_msg "${DESC} could not be stopped"
                ;;
        esac
        ;;
    status)
        check_status && exit 0 || exit $?
        ;;
    restart)
        do_stop
        log_success_msg "${DESC} was stopped"
        case "$?" in
            0|1)
                do_start
                case "$?" in
                    0) 
                        log_end_msg 0 
                        log_success_msg "${DESC} was started"
                        ;;
                    1) 
                        log_end_msg 1
                        log_failure_msg "${DESC} failed to restart"
                        ;; # Old process is still running
                    *) 
                        log_end_msg 1
                        log_failure_msg "${DESC} failed to start"
                        ;; # Failed to start
                esac
                ;;
            *)
                # Failed to stop
                log_end_msg 1
                log_failure_msg "${DESC} failed to stop"
                ;;
        esac
        ;;
    *)
        echo "Usage: $SCRIPTNAME {start|stop|status|restart}" >&2
        exit 3
        ;;
    esac

:
